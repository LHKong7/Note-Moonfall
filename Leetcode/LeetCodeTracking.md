# 4/9



### 780 reaching points

##### 问题描述

给定四个整数 sx , sy ，tx 和 ty，如果通过一系列的转换可以从起点 (sx, sy) 到达终点 (tx, ty)，则返回 true，否则返回 false。

从点 (x, y) 可以转换到 (x, x+y)  或者 (x+y, y)。

##### 用例：

```
输入: sx = 1, sy = 1, tx = 3, ty = 5
输出: true
解释:
可以通过以下一系列转换从起点转换到终点：
(1, 1) -> (1, 2)
(1, 2) -> (3, 2)
(3, 2) -> (3, 5)
```

##### 解法分类：

​	**反向计算**:

​		如果从起点 sx和sy 开始正向计算，则可能的情况非常多会超出时间限制

​		对于给定状态 tx 和 ty 只有当 tx &ne; ty 时才存在上一个状态，且上一个状态唯一 情况如下：

- 如果 tx = ty 不存在上一个状态，状态 tx ty 就是起点状态
- 如果 tx > ty 则上一个状态是 (tx - ty, ty)
- 如果 tx < ty 则上一个状态是 (tx, ty-tx)

由于每一步反向操作一定是将 tx 和 ty 中的较大的值减小，因此

​		当 tx > ty 时可以直接将 tx 的值更新为 tx mod ty 

​		当 tx<ty 时可以直接将 ty 的值更新为 ty mod tx

当反向操作的条件不成立时，根据 tx 和 ty 的不同情况分别判断是否可以从起点转换到终点。

- 如果 tx=sx 且 ty=sy，则已经到达起点状态，因此可以从起点转换到终点。
- 如果 tx=sx 且 ty &ne; sy，则 tx 不能继续减小，只能减小 ty，因此只有当 ty>sy 且 `(ty−sy) mod tx=0` 时可以从起点转换到终点。

- 如果 ty=sy 且tx &ne; sx，则 ty 不能继续减小，只能减小 tx，因此只有当tx>sx 且 `(tx−sx) mod ty=0` 时可以从起点转换到终点。

- tx &ne; sx 且 ty &ne; sy，则不可以从起点转换到终点。



# 4/10



### 189 rotate Array

#### 问题描述

给你一个数组，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

### 用例：

```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
```

#### 解法分类：

##### 解法一：使用额外的数组

使用新额外数组来将每个元素放到正确的位置，用 n 表示数组的长度，遍历原数组，将原数组下标为 `i` 的元素放到新数组下标为 `(i + k) mod n` 的位置，



- 时间复杂度： O*(*n)，其中 n 为数组的长度。
- 空间复杂度： *O*(*n*)。



##### 解法二： 环状替换

可以将被替换的元素保存在变量 `temp` 中，从而避免了额外数组的开销。

从位置0开始，使用 `temp = nums[0]`。 使用 `(i + k) % n `

​	根据规则： 

- 位置 0 的元素会放到 `(0 + k) mod n` 的位置， 令 `x = (0 + k) mod n` 交换 temp 和 nums[x] 完成位置 x 的更新
- 考察位置 x， 并交换 temp 和 `nums[(x + k) mod n]` 从而完成下一个位置的更新。不断进行上述过程，直至回到初始位置0





### 977 sortedSqure

#### 问题描述

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。



### 用例：

```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

#### 解法分类：

##### 解法一： 双指针

如果数组 `nums` 中的所有数都是非负数，那么将每个数平方后，数组仍然保持升序；

如果数组 `nums` 中的所有数都是负数，那么将每个数平方后，数组会保持降序。

这样一来，如果我们能够找到数组nums 中负数与非负数的分界线，那么就可以用类似「归并排序」的方法了。具体地，我们设 neg 为数组 nums 中负数与非负数的分界线，

也就是说，`nums[0]` 到 `nums[neg]` 均为负数，而 `nums[neg+1]` 到  `nums[n−1]` 均为非负数。当我们将数组 `nums` 中的数平方后，那么 `nums[0]` 到 `nums[neg]` 单调递减，`nums[neg+1]` 到 `nums[n−1]` 单调递增。







##### 解法二： 双指针

同样地，我们可以使用两个指针分别指向位置 00 和 n-1n−1，每次比较两个指针对应的数，选择较大的那个逆序放入答案并移动指针。这种方法无需处理某一指针移动至边界的情况，读者可以仔细思考其精髓所在。