### Bitwise Operation



## basic concepts

有符号整数，即最高位为符号位

整数一般使用补码来表示

**反码**： 符号位不变，其他位取反

**正整数的补码** === *原码*

**负整数的补码** ===  *反码 + 1*



```
1000 -> 1111 -> 1000 -> -8

1001 -> 减1 -> 1000 ->取反 1111 -> -7

1010 -6 


32位 【-2^31, 2^31-1】
```



按位取反 ~

```
4 位
~9 = -10

9 的原码 : 1001
9 的补码： 01001 0表示正数
取反：10110  -->  负数
10110 原码：-1 取反 10101 -> 11010
-10
```



**左移，有符号右移，无符号右移**

```
4: 0000 0000 0000 0000 0000 0000 0000 0100
4 << 2: 0000 0000 0000 0000 0000 0000 0001 0000

-4: 1111 1111 1111 1111 1111 1111 1111 1100
-4 << 2: 1111 1111 1111 1111 1111 1111 1111 0000
减1: 1111 1111 1111 1111 1111 1111 1110 1111
取反：1000 0000 0000 0000 0000 0000 0001 0000 -> -16

左移和符号没有关系

右移：
15: 0000 0000 0000 0000 0000 0000 0000 1111
15 >> 2: 0000 0000 0000 0000 0000 0000 0000 0011
15 >>> 2: 0000 0000 0000 0000 0000 0000 0000 0011
正数的有符号右移和无符号右移是一样的

无符号移动：最高位不当成符号位

负数的有符号右移是高位补1，而无符号右移高位补0
```



```
位运算技巧：

1. 拿到二进制的低16位（比如拿到高32位的低16位）： n&0xFFFF

2. 对二进制的高16位进行取反： ~(n^0xFFFF)

3. 测试第 i+1 位是否是 1:  (n & 1 << i) != 0

4. 去掉最后一位 1 ： n & (n-1)

5. 获取最后一位 1:
		n & ~n
		n & ~(n-1)
		n ^ (n & (n-1))

6: A 的位减去B的位 ：A & ~B

7. ^ 的用法技巧：
			a ^ 0 = a
			a ^ a = 0
			a^b^c = a^c^b
```











